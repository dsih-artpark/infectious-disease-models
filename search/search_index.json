{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Generalized Compartmental Modeling Framework","text":"<p>This documentation describes a modular, configurable framework for defining, simulating, and calibrating compartmental epidemiological models (SIR, SEIR, SIS, SIRS, SEIRS, and more).</p> <p>The framework is driven by a YAML configuration file and supports: - Arbitrary compartment structures and transition expressions - Dynamic ODE generation from transition rules - Simulation with <code>scipy.integrate.odeint</code> - Noise injection and sub-sampling for realistic observations - Parameter estimation using classical optimizers (Nelder\u2013Mead, BFGS, L-BFGS-B, Basin-Hopping) - Bayesian calibration via MCMC (emcee) - Diagnostics, loss landscapes, and posterior analysis</p> <p>Use the left navigation to explore the YAML specification, usage examples, extensibility notes, and debugging tips.</p>"},{"location":"#source-code","title":"Source code","text":"<p>View the source code on GitHub</p>"},{"location":"references/","title":"References","text":"<p>A collection of external resources related to epidemiological modeling and this framework.</p> <ul> <li> <p>EMOD &amp; emodpy-malaria documentation \u2014 Comprehensive guide for IDM\u2019s epidemiological modeling tools. https://docs.idmod.org/projects/emodpy-malaria/en/latest/index.html</p> </li> <li> <p>SciPy Documentation \u2014 Numerical computing library used for ODE solvers and optimization. https://docs.scipy.org/doc/scipy/</p> </li> <li> <p>emcee Documentation \u2014 Affine-invariant MCMC ensemble sampler in Python. https://emcee.readthedocs.io/</p> </li> <li> <p>Matplotlib Documentation \u2014 Plotting library used to visualize simulations and results. https://matplotlib.org/stable/contents.html</p> </li> <li> <p>PyYAML Documentation \u2014 YAML parser for loading model configurations. https://pyyaml.org/wiki/PyYAMLDocumentation</p> </li> </ul>"},{"location":"configuration/yaml_config/","title":"YAML Configuration Format","text":"<p>The framework is configured entirely via a YAML file. Each model is defined in a separate block. You can include multiple models in the same <code>config.yaml</code>.</p>"},{"location":"configuration/yaml_config/#model-definition","title":"Model Definition","text":"<p>Each model block supports the following fields:</p> <ul> <li><code>compartments</code> (<code>list[str]</code>): names of compartments in the model.</li> <li><code>parameters</code> (<code>dict[str, float]</code>): mapping of parameter names to initial values.</li> <li><code>transitions</code> (<code>dict[str, str]</code>): mapping of transitions in the form <code>\"A -&gt; B\": \"expression\"</code>.  </li> <li>Use parameter names, compartment names, and <code>N</code> (population size).  </li> <li>Example: <code>\"S -&gt; I\": \"beta * S * I / N\"</code>.</li> <li><code>population</code> (<code>int</code>): total population size.</li> <li><code>initial_conditions</code> (<code>dict[str, int]</code>): initial counts for each compartment.</li> <li><code>assumptions</code> (<code>str</code>, optional): description of model assumptions.</li> <li><code>simulation_time</code> (<code>int</code>): total number of time units to simulate.</li> <li><code>time_unit</code> (<code>str</code>): unit for simulation time (e.g. <code>\"days\"</code>, <code>\"years\"</code>).</li> </ul>"},{"location":"configuration/yaml_config/#plot-settings","title":"Plot Settings","text":"<p>Each model may specify plotting options:</p> <ul> <li><code>y_scale</code> (<code>str</code>): <code>\"linear\"</code> (default) or <code>\"log\"</code>.  </li> <li><code>scale_by_population</code> (<code>bool</code>): if <code>true</code>, all values are normalized by population size.</li> </ul>"},{"location":"configuration/yaml_config/#calibration-settings","title":"Calibration Settings","text":"<p>Each model may specify calibration options:</p> <ul> <li><code>target_data</code> (<code>str</code>): CSV file with observed data (must be placed in <code>data/&lt;model_name&gt;/</code>).  </li> <li><code>noise_std</code> (<code>float</code>): standard deviation of Gaussian noise (used when generating synthetic data).</li> <li><code>subset_ratio</code> (<code>float</code>): fraction of time points to randomly sample for fitting (0.0\u20131.0).</li> <li><code>optimizers</code> (<code>list[str]</code>): optimizers to run (e.g., <code>[\"Nelder-Mead\", \"BFGS\", \"L-BFGS-B\"]</code>).</li> <li><code>update_config</code> (<code>bool</code>): if <code>true</code>, fitted parameters overwrite config.</li> <li><code>parameter_bounds</code> (<code>dict[str, [float, float]]</code>): bounds for parameters.</li> </ul>"},{"location":"configuration/yaml_config/#example-sir-model","title":"Example: SIR model","text":"<pre><code>SIR_model:\n  compartments: [S, I, R]\n  parameters: {beta: 0.25, gamma: 0.15, mu: 0.015}\n  transitions: {\"S -&gt; I\": \"beta * S * I / N\", \"I -&gt; R\": \"gamma * I\", \"-&gt; S\": \"mu * N\", \"S -&gt;\": \"mu * S\", \"I -&gt;\": \"mu * I\", \"R -&gt;\": \"mu * R\"}\n  population: 1000\n  initial_conditions: {S: 990, I: 10, R: 0}\n  assumptions: \"The population is closed (no births or deaths). The disease is transmitted through direct contact. Immunity is permanent after recovery.\"\n  simulation_time: 160\n  time_unit: days\n  plot_settings:\n    y_scale: linear\n    scale_by_population: false\n  calibration_settings:\n    target_data: noisy_data.csv \n    noise_std: 5.0\n    subset_ratio: 0.7\n    optimizers: [Nelder-Mead, BFGS, L-BFGS-B]\n    update_config: false\n    parameter_bounds:\n      beta: [0.0, 5.0]\n      gamma: [0.0, 2.0]\n      mu: [0.0, 1.0]\n</code></pre>"},{"location":"configuration/yaml_config/#syntax-rules","title":"Syntax rules","text":"<ul> <li>Use Python-style arithmetic in transition expressions (e.g. <code>beta * S * I / N</code>).</li> <li>Division by <code>N</code> is explicit; include <code>N</code> in expressions when needed.</li> <li>Parameter names and compartment names are case-sensitive.</li> <li>You may add additional model blocks in the same file for batch simulations.</li> </ul>"},{"location":"debugging/improvements/","title":"Improvements","text":"<ul> <li>Relaxed prior bounds to encourage better exploration.</li> <li>Smarter walker initialization (spread inside prior region).</li> <li>Added checks to skip parameter sets that produce unstable ODE solutions.</li> <li>Improved plotting routines: explicit <code>savefig()</code> and <code>plt.close()</code> to prevent file locking.</li> <li>Exposed hooks to allow custom loss functions and time-varying parameters.</li> </ul>"},{"location":"debugging/issues_encountered/","title":"Issues Encountered","text":""},{"location":"debugging/issues_encountered/#1-numerical-instability-nans","title":"1. Numerical instability / NaNs","text":"<ul> <li>ODE solver can produce NaNs for extreme parameter values.</li> <li>Fixes: check parameter bounds, improve initialization, catch exceptions and return large loss.</li> </ul>"},{"location":"debugging/issues_encountered/#2-stiff-dynamics","title":"2. Stiff dynamics","text":"<ul> <li>Some parameter regimes are stiff (very small or large rates).</li> <li>Fixes: use a stiff solver (e.g., <code>scipy.integrate.solve_ivp</code> with <code>method='BDF'</code>), tighten tolerances.</li> </ul>"},{"location":"debugging/issues_encountered/#3-overfitting-to-noise","title":"3. Overfitting to noise","text":"<ul> <li>Deterministic optimizers can pick parameters that explain a particular noise realization.</li> <li>Fixes: regularize loss, fit across multiple noise realizations, or use Bayesian inference.</li> </ul>"},{"location":"debugging/issues_encountered/#4-mcmc-walker-initialization-problems","title":"4. MCMC walker initialization problems","text":"<ul> <li>Walkers outside priors cause immediate failure.</li> <li>Fixes: sample initial walker positions from a distribution strictly inside priors.</li> </ul>"},{"location":"dev/","title":"Developer Guide","text":"<p>This guide is for developers and contributors who want to understand the internal architecture of the Generalized Compartmental Modeling Framework.</p> <p>The User-facing pages explain how to run models and interpret results, but this section focuses on the code internals \u2014 how modules, classes, and functions work together.</p>"},{"location":"dev/#purpose","title":"Purpose","text":"<p>The Developer Guide will help you: - Understand the structure and flow of the codebase - Extend the framework with new models, fitting methods, or visualizations - Maintain and debug existing functionality</p>"},{"location":"dev/#high-level-architecture","title":"High-Level Architecture","text":"<p>The framework follows a modular design:</p> <ol> <li> <p>Main Controller (<code>main.py</code>) </p> <ul> <li>Parses CLI arguments (<code>--model &lt;model_name&gt;</code>)  </li> <li>Loads the YAML configuration  </li> <li>Orchestrates the workflow: simulation \u2192 noise injection \u2192 sampling \u2192 calibration \u2192 plotting \u2192 saving outputs  </li> </ul> </li> <li> <p>Core Model Logic (<code>model.py</code>) </p> <ul> <li><code>Population</code> \u2014 Population size &amp; assumptions  </li> <li><code>CompartmentalModel</code> \u2014 Builds and simulates the ODE system  </li> </ul> </li> <li> <p>Calibration Layer (<code>calibration.py</code>) </p> <ul> <li>Optimization (Nelder-Mead, BFGS, L-BFGS-B, etc.)  </li> <li>MCMC for Bayesian inference  </li> <li>Loss calculation functions  </li> </ul> </li> <li> <p>Plotting Layer (<code>plotting.py</code>) </p> <ul> <li>Generates simulation plots, noisy data plots, comparisons, parameter estimation graphs, and MCMC corner plots  </li> </ul> </li> </ol>"},{"location":"dev/#workflow-for-developers","title":"Workflow for Developers","text":"<ol> <li>Add or modify models in the YAML configuration  </li> <li>Update model logic in <code>model.py</code> if new compartments or transitions are needed  </li> <li>Extend calibration methods in <code>calibration.py</code> for new fitting techniques  </li> <li>Enhance visualization in <code>plotting.py</code> for additional plots or formats  </li> <li>Test your changes with:     <pre><code>python main.py --model &lt;model_name&gt;\n</code></pre></li> </ol>"},{"location":"dev/calibration/","title":"Calibration Module","text":"<p>The <code>calibration.py</code> module provides tools for fitting model parameters to data using both optimization methods and Bayesian inference (MCMC). This is essential when comparing simulated epidemic trajectories with noisy or real-world data.</p>"},{"location":"dev/calibration/#overview","title":"Overview","text":"<p>Calibration enables:</p> <ul> <li>Parameter estimation from data.</li> <li>Comparison of different optimization strategies (Nelder-Mead, BFGS, L-BFGS-B).</li> <li>Bayesian inference via MCMC sampling (<code>emcee</code>) for posterior distributions.</li> <li>Integration with the <code>main.py</code> workflow for end-to-end simulation and fitting.</li> </ul>"},{"location":"dev/calibration/#key-components","title":"Key Components","text":""},{"location":"dev/calibration/#loss_functiontheta-model-sampled_times-observed_data-fit_compartments","title":"<code>loss_function(theta, model, sampled_times, observed_data, fit_compartments)</code>","text":"<p>Computes the loss between simulated and observed data for specified compartments.</p> <p>Parameters - <code>theta</code> (<code>list[float]</code>) \u2014 Candidate parameter vector. - <code>model</code> (<code>CompartmentalModel</code>) \u2014 Model instance to simulate. - <code>sampled_times</code> (<code>list[float]</code>) \u2014 Time points to evaluate the simulation. - <code>observed_data</code> (<code>np.ndarray</code>) \u2014 Observed noisy or real data. - <code>fit_compartments</code> (<code>list[str]</code>) \u2014 Compartments included in the loss calculation.</p> <p>Returns - A scalar loss value (lower is better).</p>"},{"location":"dev/calibration/#fit_with_optimizersmodel-optimizers","title":"<code>fit_with_optimizers(model, optimizers, ...)</code>","text":"<p>Fits model parameters using classical optimization algorithms.</p> <p>Supported optimizers - Nelder-Mead - BFGS - L-BFGS-B</p> <p>Returns - Dictionary of fitted parameters and loss values for each optimizer.</p>"},{"location":"dev/calibration/#run_mcmcmodel","title":"<code>run_mcmc(model, ...)</code>","text":"<p>Runs Bayesian calibration with the emcee sampler.</p> <p>Workflow 1. Define prior bounds for parameters. 2. Initialize walkers inside the prior region. 3. Simulate the model for each walker position. 4. Compute log-likelihood vs. observed data. 5. Generate posterior samples for uncertainty quantification.</p> <p>Returns - <code>sampler</code> object containing posterior chains.</p>"},{"location":"dev/calibration/#usage-in-mainpy","title":"Usage in <code>main.py</code>","text":"<p>Calibration is optional and controlled via CLI flags:</p> <pre><code>python main.py --model SIR_model --calibrate --compartment I\n</code></pre>"},{"location":"dev/model/","title":"Model Module","text":"<p>The <code>model.py</code> module defines the core classes for epidemic simulation: Population and CompartmentalModel. These classes handle ODE integration, state transitions, noise injection, and sampling of timepoints.</p>"},{"location":"dev/model/#population-class","title":"Population Class","text":""},{"location":"dev/model/#purpose","title":"Purpose","text":"<p>Represents the population in which the epidemic model runs and validates initial conditions.</p>"},{"location":"dev/model/#attributes","title":"Attributes","text":"<ul> <li><code>N</code> (int) \u2014 Total population size.</li> <li><code>assumptions</code> (str, optional) \u2014 Description of model assumptions.</li> </ul>"},{"location":"dev/model/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, N, assumptions=None)</code>   Validates that <code>N &gt; 0</code>. Stores population size and optional assumptions.</li> <li><code>__repr__(self)</code>   Returns a human-readable summary of the population.</li> </ul>"},{"location":"dev/model/#compartmentalmodel-class","title":"CompartmentalModel Class","text":""},{"location":"dev/model/#purpose_1","title":"Purpose","text":"<p>Encapsulates all model logic, including:</p> <ul> <li>ODE simulation of compartments</li> <li>Noise injection for synthetic data</li> <li>Sampling of time points for calibration</li> </ul>"},{"location":"dev/model/#attributes_1","title":"Attributes","text":"<ul> <li><code>compartments</code> (list[str]) \u2014 Names of model compartments.</li> <li><code>parameters</code> (dict) \u2014 Parameter name \u2192 value.</li> <li><code>transitions</code> (dict) \u2014 Mapping <code>FROM-&gt;TO</code> \u2192 expression string.</li> <li><code>population</code> (Population) \u2014 Linked population object.</li> <li><code>initial_conditions</code> (dict) \u2014 Initial compartment values.</li> </ul>"},{"location":"dev/model/#key-methods","title":"Key Methods","text":"<ul> <li><code>compute_transition_rates(self, y, params)</code>   Evaluates transition rates for a given state and parameter set.</li> <li><code>compute_rhs(self, t, y, params)</code>   Constructs the system of ODEs (<code>dC/dt</code>) for integration.</li> <li><code>simulate(self, y0, t, params)</code>   Integrates the ODE system using <code>odeint</code> or <code>solve_ivp</code>.</li> <li><code>add_noise(self, trajectories, sigma)</code>   Adds Gaussian noise to simulation outputs.</li> <li><code>sample_timepoints(self, trajectories, ratio)</code>   Randomly selects observation points for parameter fitting or calibration.</li> </ul>"},{"location":"dev/model/#example-usage","title":"Example Usage","text":"<pre><code>from model import Population, CompartmentalModel\n\n# Define population\npop = Population(N=1000)\n\n# Define SIR model\nsir_model = CompartmentalModel(\n    compartments=[\"S\", \"I\", \"R\"],\n    parameters={\"beta\": 0.3, \"gamma\": 0.1},\n    transitions={\"S-&gt;I\": \"beta * S * I / N\", \"I-&gt;R\": \"gamma * I\"},\n    population=pop,\n    initial_conditions={\"S\": 990, \"I\": 10, \"R\": 0}\n)\n\n# Run simulation\nt, y = sir_model.simulate(y0={\"S\": 990, \"I\": 10, \"R\": 0}, t=np.linspace(0, 160, 161))\n</code></pre>"},{"location":"dev/plotting/","title":"Plotting Module","text":"<p>The <code>plotting.py</code> module provides utilities for visualizing simulation results, noisy data, parameter estimation, and MCMC posterior distributions.</p>"},{"location":"dev/plotting/#functions","title":"Functions","text":""},{"location":"dev/plotting/#plot_simulation_onlytime_points-compartments-true_data-plot_dir-model_cfgnone-populationnone-compartment_choicenone","title":"<code>plot_simulation_only(time_points, compartments, true_data, plot_dir, model_cfg=None, population=None, compartment_choice=None)</code>","text":"<p>Plots the clean simulation trajectories for all compartments, optionally highlighting a chosen compartment. Parameters - <code>time_points</code> \u2014 Array of time points. - <code>compartments</code> \u2014 List of compartment names. - <code>true_data</code> \u2014 Simulated trajectories. - <code>plot_dir</code> \u2014 Directory to save plots. - <code>model_cfg</code> \u2014 Optional model configuration (for scaling/time units). - <code>population</code> \u2014 Population size for per-unit scaling. - <code>compartment_choice</code> \u2014 Compartment to highlight.</p>"},{"location":"dev/plotting/#plot_calibration_resultstime_points-compartments-true_data-noisy_data-subset_t-subset_infected-fitted_results-model_name-plot_dir-true_paramsnone-param_namesnone-mcmc_samplernone-model_cfgnone-populationnone-compartment_choicei","title":"<code>plot_calibration_results(time_points, compartments, true_data, noisy_data, subset_t, subset_infected, fitted_results, model_name, plot_dir, true_params=None, param_names=None, mcmc_sampler=None, model_cfg=None, population=None, compartment_choice=\"I\")</code>","text":"<p>Generates comprehensive calibration plots, including:</p> <ol> <li>Noisy data for all compartments  </li> <li>Comparison of true vs noisy vs fitted trajectories for calibration compartments  </li> <li>Parameter estimation bar plots for fitted parameters and MCMC mean  </li> <li>MCMC corner plot  </li> </ol> <p>Parameters - <code>time_points</code> \u2014 Array of simulation time points. - <code>compartments</code> \u2014 List of compartment names. - <code>true_data</code> \u2014 Clean simulated trajectories. - <code>noisy_data</code> \u2014 Noisy observed data. - <code>subset_t</code> \u2014 Time points used for fitting. - <code>subset_infected</code> \u2014 Observed data for calibration compartments. - <code>fitted_results</code> \u2014 Dictionary of fitted results from optimizers. - <code>model_name</code> \u2014 Name of the model. - <code>plot_dir</code> \u2014 Directory to save plots. - <code>true_params</code> \u2014 Optional dictionary of true parameter values. - <code>param_names</code> \u2014 List of parameter names for plotting. - <code>mcmc_sampler</code> \u2014 Optional emcee sampler object for posterior visualization. - <code>model_cfg</code> \u2014 Optional model configuration for scaling/time settings. - <code>population</code> \u2014 Population size for per-unit scaling. - <code>compartment_choice</code> \u2014 Compartment(s) to highlight in plots.</p>"},{"location":"dev/plotting/#example-usage","title":"Example Usage","text":"<pre><code>from plotting import plot_simulation_only, plot_calibration_results\n\n# Plot clean simulation\nplot_simulation_only(time_points, compartments, true_data, \"plots/SIR_model\")\n\n# Plot calibration results\nplot_calibration_results(\n    time_points,\n    compartments,\n    true_data,\n    noisy_data,\n    subset_t,\n    subset_infected,\n    fitted_results,\n    \"SIR_model\",\n    \"plots/SIR_model\",\n    true_params=PARAMS,\n    param_names=list(PARAMS.keys()),\n    mcmc_sampler=sampler\n)\n</code></pre>"},{"location":"features/advanced_features/","title":"Advanced Features","text":"<ul> <li>Time-dependent parameters via <code>extras_fn(t, y)</code>.</li> <li>Selective observation model: fit only some compartments or use different noise models per compartment.</li> <li>Checkpointing: save intermediate parameter states during long runs.</li> <li>Loss landscape visualization: grid-evaluate loss over parameter pairs and contour plot in log-scale.</li> <li>Posterior diagnostics: corner plots (e.g., using <code>corner</code>), trace plots, autocorrelation.</li> </ul>"},{"location":"features/extensibility/","title":"Extensibility","text":"<p>This framework was designed to be extensible. Common extension points:</p>"},{"location":"features/extensibility/#1-new-compartment-models","title":"1. New compartment models","text":"<p>Add a new block in the YAML with compartments and transitions \u2014 no code changes needed.</p>"},{"location":"features/extensibility/#2-new-parameter-types","title":"2. New parameter types","text":"<p>Add parameters to the <code>parameters</code> map. For time-varying parameters, implement <code>extras_fn</code>.</p>"},{"location":"features/extensibility/#3-custom-loss-functions","title":"3. Custom loss functions","text":"<p>Provide a Python callable to compute the loss instead of MSE. For example, weighted MSE or Poisson log-likelihood for count data.</p>"},{"location":"features/extensibility/#4-metapopulation-network-models","title":"4. Metapopulation / Network models","text":"<ul> <li>Extend <code>transitions</code> syntax to include indices or use multiple population blocks.</li> <li>The ODE generator will need to be extended to create vectorized compartments per patch.</li> </ul>"},{"location":"features/extensibility/#5-new-optimizers-or-inference-engines","title":"5. New optimizers or inference engines","text":"<ul> <li>Add wrappers for other optimizers (e.g., CMA-ES, differential evolution).</li> <li>Add MCMC engines (e.g., PyMC, NumPyro) by mapping log-posterior.</li> </ul>"},{"location":"features/outputs/","title":"Outputs","text":"<p>The framework produces:</p>"},{"location":"features/outputs/#data-files-csv","title":"Data files (CSV)","text":"<p>Located in <code>data/&lt;model_name&gt;/</code>:</p> <ul> <li><code>true_data.csv</code> \u2014 clean simulation trajectories</li> <li><code>noisy_data.csv</code> \u2014 noisy observed trajectories</li> <li><code>time_points.csv</code> \u2014 sampled observation points used for fitting</li> </ul>"},{"location":"features/outputs/#plots-png","title":"Plots (PNG)","text":"<p>Located in <code>plots/&lt;model_name&gt;/</code>:</p> <ul> <li><code>plot_simulation.png</code> \u2014 clean trajectories of all compartments</li> <li><code>plot_noisy.png</code> \u2014 noisy simulated data</li> <li><code>plot_comparison.png</code> \u2014 fitted vs. true trajectories</li> <li><code>parameter_estimation.png</code> \u2014 fitted parameter summary</li> <li><code>mcmc_corner_plot.png</code> \u2014 posterior distributions (if MCMC is run)</li> </ul>"},{"location":"features/outputs/#recommended-directory-layout","title":"Recommended directory layout","text":"<pre><code>plots/\n  \u2514\u2500 SIR_model/\n      \u251c\u2500 plot_simulation.png\n      \u251c\u2500 plot_noisy.png\n      \u251c\u2500 plot_comparison.png\n      \u251c\u2500 parameter_estimation.png\n      \u2514\u2500 mcmc_corner_plot.png\n\ndata/\n  \u2514\u2500 SIR_model/\n      \u251c\u2500 true_data.csv\n      \u251c\u2500 noisy_data.csv\n      \u2514\u2500 time_points.csv\n</code></pre>"},{"location":"models/TB_Kuddus_2022/","title":"TB_Kuddus_2022 Model","text":""},{"location":"models/TB_Kuddus_2022/#overview","title":"Overview","text":"<p>Kuddus et al. (2022) proposed a two-strain tuberculosis (TB) model to study drug-susceptible (DS) and drug-resistant (DR) TB dynamics in Bangladesh.  </p> <p>In this model, the total population <code>N</code> is divided into six mutually exclusive compartments:  </p> <ul> <li><code>S</code>: Susceptible  </li> <li><code>Ls</code>: Latently infected with drug-susceptible TB  </li> <li><code>Is</code>: Infectious with drug-susceptible TB  </li> <li><code>Lr</code>: Latently infected with drug-resistant TB  </li> <li><code>Ir</code>: Infectious with drug-resistant TB  </li> <li><code>R</code>: Recovered  </li> </ul>"},{"location":"models/TB_Kuddus_2022/#transition-diagram","title":"Transition Diagram","text":"<pre><code>flowchart LR\n    S --&gt;|\"\u03b2s * Is * S / N\"| Ls\n    S --&gt;|\"\u03b2r * Ir * S / N\"| Lr\n    Ls --&gt;|\"\u03b1s * Ls\"| Is\n    Lr --&gt;|\"\u03b1r * Lr\"| Ir\n    Is --&gt;|\"\u03c9s * Is\"| R\n    Ir --&gt;|\"\u03c9r * Ir\"| R\n    Is --&gt;|\"\u03c1 * \u03c4s * Is\"| Ir\n    Is --&gt;|\"\u03c6s * Is\"| S\n    Ir --&gt;|\"\u03c6r * Ir\"| S\n    R --&gt;|\"\u03b3 * R\"| S\n    N --&gt;|\"\u03bc * N\"| S\n    S --&gt;|\"\u03bc * S\"| X1[\u2205]\n    Ls --&gt;|\"\u03bc * Ls\"| X2[\u2205]\n    Is --&gt;|\"\u03bc * Is\"| X3[\u2205]\n    Lr --&gt;|\"\u03bc * Lr\"| X4[\u2205]\n    Ir --&gt;|\"\u03bc * Ir\"| X5[\u2205]\n    R --&gt;|\"\u03bc * R\"| X6[\u2205]</code></pre>"},{"location":"models/TB_Kuddus_2022/#tb_kuddus_2022-model-configuration","title":"TB_Kuddus_2022 Model Configuration","text":"<p>Below is an example configuration for the TB_Kuddus_2022 model in YAML format.</p> <pre><code>TB_Kuddus_2022_model:   \n  compartments: [S, Ls, Is, Lr, Ir, R]\n  parameters: {mu: 0.0142857, beta_s: 1.57e-8, beta_r: 6.25e-9, alpha_s: 0.129, alpha_r: 0.129, omega_s: 0.287, omega_r: 0.12, rho: 0.07, phi_s: 0.37, phi_r: 0.37, tau_s: 0.94, tau_r: 0.78, gamma: 0.1 }\n  transitions: {\"R -&gt; S\": \"gamma * R\", \"Is -&gt; S\": \"phi_s * Is\", \"Ir -&gt; S\": \"phi_r * Ir\", \"S -&gt; Ls\": \"beta_s * Is * S / N\", \"S -&gt; Lr\": \"beta_r * Ir * S / N\",\"S -&gt;\": \"mu * S\", \"-&gt; S\": \"mu * N\", \"Ls -&gt; Is\": \"alpha_s * Ls\", \"Ls -&gt;\": \"mu * Ls\", \"Is -&gt; R\": \"omega_s * Is\", \"Is -&gt; R_extra\": \"(1 - rho) * tau_s * Is\" , \"Is -&gt;\": \"mu * Is\", \"Is -&gt; Ir\": \"rho * tau_s * Is\", \"Lr -&gt; Ir\": \"alpha_r * Lr\", \"Lr -&gt;\": \"mu * Lr\", \"Ir -&gt; R\": \"omega_r * Ir\", \"Ir -&gt; R_extra\": \"tau_r * Ir\", \"Ir -&gt;\": \"mu * Ir\", \"Ir -&gt; S\": \"phi_r * Ir\", \"R -&gt;\": \"mu * R\"}\n  population: 100000\n  initial_conditions: {Ls: 400, Is: 300, Lr: 10, Ir: 400, R: 5, S: 98885}\n  assumptions: TB transmission with drug-sensitive (DS) and drug-resistant (DR) strains, based on Kuddus (2022).\n  simulation_time: 15\n  time_unit: years\n  plot_settings:\n    y_scale: linear\n    scale_by_population: true   \n    per_unit: 100000   \n  calibration_settings:   \n    target_data: TB_synthetic_data.csv # or file_name.csv for real data  \n    noise_std: 5.0\n    subset_ratio: 0.7\n    optimizers: [Nelder-Mead, BFGS, L-BFGS-B]\n    update_config: false        \n</code></pre>"},{"location":"models/TB_Sulayman_2021/","title":"TB_Sulayman_2021 Model","text":""},{"location":"models/TB_Sulayman_2021/#overview","title":"Overview","text":"<p>This model is adapted from Sulayman et al. (2021), who divide the total population \\(N\\) into five mutually exclusive classes:</p> <ul> <li>S: Susceptible individuals  </li> <li>V: Vaccinated individuals  </li> <li>E: Exposed (latently infected, not yet infectious) Individuals</li> <li>I: Infectious individuals </li> <li>R: Recovered individuals  </li> </ul>"},{"location":"models/TB_Sulayman_2021/#biological-interpretation","title":"Biological Interpretation","text":"<ul> <li>Susceptible (S) individuals are those at risk of acquiring TB infection.  </li> <li>Vaccinated (V) individuals have received a vaccine, which reduces their risk of infection but may wane over time (waning immunity, parameter \\(\\theta\\)).  </li> <li>Latently infected (E) individuals harbor the TB pathogen without showing clinical symptoms. They are unaware of their condition until diagnosed, often by a tuberculin skin test.  </li> <li>Latency can be fast (1\u20135 years) or slow (several years).  </li> <li>Undiagnosed infectious (I1) are actively infectious but not yet diagnosed.  </li> <li>Diagnosed infectious (I2) are identified as TB cases and may transition to treatment.  </li> <li>Treated individuals (T) undergo therapy, but reinfection is possible (\\(\\sigma\\)).  </li> <li>Recovered (R) individuals regain health, but may not acquire permanent immunity and can be reinfected (\\(p\\)).  </li> </ul>"},{"location":"models/TB_Sulayman_2021/#model-assumptions","title":"Model Assumptions","text":"<ul> <li>The population is dynamic, with recruitment (\\(\\Lambda\\)) and natural death (\\(\\mu\\)).  </li> <li>Vaccination occurs at rate \\(\\xi\\), and vaccine efficacy (\\(\\omega\\)) reduces susceptibility.  </li> <li>Vaccination protection wanes at rate \\(\\theta\\).  </li> <li>Transmission occurs via force of infection:</li> </ul> \\[ \\lambda = \\frac{\\beta c (I_1 + I_2)}{N} \\] <ul> <li>Latently infected individuals may progress to active TB (\\(E \\to I_1\\) or \\(E \\to I_2\\)) at rate \\(k\\).  </li> <li>Treated individuals can experience reinfection (\\(\\sigma\\)) or recover fully (\\(\\tau\\)).  </li> <li>Exogenous reinfection occurs at rate \\(p\\).  </li> <li>TB-induced deaths occur in infectious compartments at rate \\(\\delta\\).  </li> </ul>"},{"location":"models/TB_Sulayman_2021/#compartmental-diagram","title":"Compartmental Diagram","text":"<pre><code>flowchart LR\n    %% Compartments\n    S[\"S\"] --&gt;|\"\u03be \u00b7 S\"| V[\"V\"]\n    V --&gt;|\"\u03b8 \u00b7 V\"| S\n\n    S --&gt;|\"\u03b2 \u00b7 S \u00b7 I\"| E[\"E\"]\n    V --&gt;|\"\u03c9 \u00b7 \u03b2 \u00b7 V \u00b7 I\"| E\n\n    E --&gt;|\"k \u00b7 E + p \u00b7 \u03b2 \u00b7 E \u00b7 I\"| I[\"I\"]\n\n    I --&gt;|\"\u03c4 \u00b7 I\"| R[\"R\"]\n    I --&gt;|\"\u03b4 \u00b7 I\"| X1[\u2205]\n\n    R --&gt;|\"\u03c3 \u00b7 \u03b2 \u00b7 I \u00b7 R\"| E\n\n    %% Recruitment and natural death\n    N[\" \"] --&gt;|\"\u039b\"| S\n    S --&gt;|\"\u03bc \u00b7 S\"| X2[\u2205]\n    V --&gt;|\"\u03bc \u00b7 V\"| X3[\u2205]\n    E --&gt;|\"\u03bc \u00b7 E\"| X4[\u2205]\n    I --&gt;|\"\u03bc \u00b7 I\"| X5[\u2205]\n    R --&gt;|\"\u03bc \u00b7 R\"| X6[\u2205]\n</code></pre>"},{"location":"models/TB_Sulayman_2021/#tb_sulayman_2021-model-configuration","title":"TB_Sulayman_2021 Model Configuration","text":"<p>Below is an example configuration for the TB_Sulayman_2021 model in YAML format.</p> <pre><code>TB_sulayman_2021_model:   \n  compartments: [S, V, E, I, R]\n  parameters: {Lambda: 5, mu: 0.15, beta: 0.25, theta: 0.069, xi: 0.5, omega: 0.5, k: 0.02, tau: 2.5, delta: 0.12, sigma: 0.5, p: 0.5}\n  transitions: {\"-&gt; S\": \"Lambda\", \"S -&gt; V\": \"xi * S\", \"V -&gt; S\": \"theta * V\", \"S -&gt; E\": \"beta * S * I\", \"V -&gt; E\": \"omega * betaa * V * I\", \"E -&gt; I\": \"k * E + p * beta * E * I\", \"I -&gt; R\": \"tau * I\", \"I -&gt;\": \"(mu + delta) * I\", \"S -&gt;\": \"mu * S\", \"V -&gt;\": \"mu * V\", \"E -&gt;\": \"mu * E\", \"I -&gt;\": \"mu * I\", \"R -&gt;\": \"mu * R\", \"R -&gt; E\": \"sigma * beta * I * R\"}\n  population: 100000\n  assumptions: |\n    Sulayman et al. (2021) propose an SVEIRE TB model incorporating:\n      - Vaccination (V) with waning immunity (\u03b8) and imperfect efficacy (\u03c9)\n      - Exogenous reinfection (p) and reinfection among recovered (\u03c3)\n      - Natural mortality (\u03bc) and TB-induced mortality (\u03b4)\n      - Recruitment inflow (\u039b)\n      - Disease progression from exposed (E) to infected (I) via rate (k)\n      - Recovery of infected individuals at rate (\u03c4)\n  simulation_time: 50\n  time_unit: years\n  plot_settings:\n    y_scale: linear\n    scale_by_population: true   \n    per_unit: 100000\n  calibration_settings:\n    target_data: TB_data.csv # or file_name.csv for real data  \n    noise_std: 5.0\n    subset_ratio: 0.7\n    optimizers: [Nelder-Mead, BFGS, L-BFGS-B]\n    update_config: false\n</code></pre>"},{"location":"models/seir/","title":"SEIR Model","text":"<p>The SEIR model is one of the simplest compartmental models in epidemiology. It divides the population into four compartments:  </p> <ul> <li>S (Susceptible): Individuals who are healthy but can contract the disease.  </li> <li>E (Exposed): Individuals who have been infected but are not yet infectious (in the incubation period).</li> <li>I (Infected): Individuals currently infected and able to spread the disease.  </li> <li>R (Recovered): Individuals who have recovered and gained immunity. </li> </ul>"},{"location":"models/seir/#transition-diagram","title":"Transition Diagram","text":"<pre><code>flowchart LR\n    S --&gt;|\"\u03b2 * S * I / N\"| E\n    E --&gt;|\"\u03c3 * E\"| I\n    I --&gt;|\"\u03b3 * I\"| R\n    N --&gt;|\"\u03bc * N\"| S\n    S --&gt;|\"\u03bc * S\"| X1[\u2205]\n    E --&gt;|\"\u03bc * E\"| X2[\u2205]\n    I --&gt;|\"\u03bc * I\"| X3[\u2205]\n    R --&gt;|\"\u03bc * R\"| X4[\u2205]</code></pre>"},{"location":"models/seir/#seir-model-configuration","title":"SEIR Model Configuration","text":"<p>Below is an example configuration for the SEIR model in YAML format.</p> <pre><code>SEIR_model:\n compartments: [S, E, I, R] \n parameters: {beta: 0.3, sigma: 0.1, gamma: 0.1, mu: 0.01}\n transitions: {\"S -&gt; E\": \"beta * S * I / N\", \"E -&gt; I\": \"sigma * E\", \"I -&gt; R\": \"gamma * I\", \"-&gt; S\": \"mu * N\", \"S -&gt;\": \"mu * S\", \"E -&gt;\": \"mu * E\", \"I -&gt;\": \"mu * I\", \"R -&gt;\": \"mu * R\"}\n population: 1000\n initial_conditions: {S: 990, E: 0, I: 10, R: 0}\n assumptions: The population is closed (no births or deaths). The disease has an exposed stage before becoming infectious. Immunity is permanent after recovery.\n simulation_time: 160\n time_unit: days\n plot_settings:\n    y_scale: linear\n    scale_by_population: false\n calibration_settings:\n    target_data: synthetic_data.csv # or file_name.csv for real data  \n    noise_std: 5.0\n    subset_ratio: 0.7\n    optimizers: [Nelder-Mead, BFGS, L-BFGS-B]\n    update_config: false\n</code></pre>"},{"location":"models/sir/","title":"SIR Model","text":"<p>The SIR model is one of the simplest compartmental models in epidemiology. It divides the population into three compartments:  </p> <ul> <li>S (Susceptible): Individuals who are healthy but can contract the disease.  </li> <li>I (Infected): Individuals currently infected and able to spread the disease.  </li> <li>R (Recovered): Individuals who have recovered and gained immunity. </li> </ul>"},{"location":"models/sir/#transition-diagram","title":"Transition Diagram","text":"<pre><code>flowchart LR\n    S --&gt;|\"\u03b2 * S * I / N\"| I\n    I --&gt;|\"\u03b3 * I\"| R\n    dummy([ ]) --&gt;|\"\u03bc * N\"| S\n    S -.-&gt;|\"\u03bc * S\"| endS(( ))\n    I -.-&gt;|\"\u03bc * I\"| endI(( ))\n    R -.-&gt;|\"\u03bc * R\"| endR(( ))</code></pre>"},{"location":"models/sir/#sir-model-configuration","title":"SIR Model Configuration","text":"<p>Below is an example configuration for the SIR model in YAML format.</p> <pre><code>SIR_model:\n  compartments: [S, I, R]\n  parameters: {beta: 0.25, gamma: 0.15, mu: 0.015}\n  transitions: {\"S -&gt; I\": \"beta * S * I / N\", \"I -&gt; R\": \"gamma * I\", \"-&gt; S\": \"mu * N\", \"S -&gt;\": \"mu * S\", \"I -&gt;\": \"mu * I\", \"R -&gt;\": \"mu * R\"}\n  population: 1000\n  initial_conditions: {S: 990, I: 10, R: 0}\n  assumptions: \"The population is closed (no births or deaths). The disease is transmitted through direct contact. Immunity is permanent after recovery.\"\n  simulation_time: 160\n  time_unit: days\n  plot_settings:\n    y_scale: linear\n    scale_by_population: false\n  calibration_settings:\n    target_data: noisy_data.csv \n    noise_std: 5.0\n    subset_ratio: 0.7\n    optimizers: [Nelder-Mead, BFGS, L-BFGS-B]\n    update_config: false\n    parameter_bounds:\n      beta: [0.0, 5.0]\n      gamma: [0.0, 2.0]\n      mu: [0.0, 1.0]\n</code></pre>"},{"location":"models/sis/","title":"SIS Model","text":"<p>The SIS model is one of the simplest compartmental models in epidemiology. It divides the population into two compartments:  </p> <ul> <li>S (Susceptible): Individuals who are healthy but can contract the disease.  </li> <li>I (Infected): Individuals currently infected and able to spread the disease.  </li> </ul>"},{"location":"models/sis/#transition-diagram","title":"Transition Diagram","text":"<pre><code>flowchart LR\n    S --&gt;|\"\u03b2 * S * I / N\"| I\n    I --&gt;|\"\u03b3 * I\"| S\n    N --&gt;|\"\u03bc * N\"| S\n    S --&gt;|\"\u03bc * S\"| X1[\u2205]\n    I --&gt;|\"\u03bc * I\"| X2[\u2205]</code></pre>"},{"location":"models/sis/#sis-model-configuration","title":"SIS Model Configuration","text":"<p>Below is an example configuration for the SIS model in YAML format.</p> <pre><code>SIS_model:\n  compartments: [S, I]\n  parameters: {beta: 0.3, gamma: 0.1, mu: 0.01}\n  transitions: {\"S -&gt; I\": \"beta * S * I / N\", \"I -&gt; S\": \"gamma * I\", \"-&gt; S\": \"mu * N\", \"S -&gt;\": \"mu * S\", \"I -&gt;\": \"mu * I\"}\n  population: 1000\n  initial_conditions: {S: 990, I: 10}\n  assumptions: The population is closed (no births or deaths). The disease does not confer permanent immunity. After recovery, individuals return to the susceptible class (no immunity).\n  simulation_time: 160\n  time_unit: days\n  plot_settings:\n    y_scale: linear\n    scale_by_population: false\n  calibration_settings:\n    target_data: synthetic_data.csv # or file_name.csv for real data    \n    noise_std: 5.0\n    subset_ratio: 0.7\n    optimizers: [Nelder-Mead, BFGS, L-BFGS-B]\n    update_config: false\n</code></pre>"},{"location":"models/time_varying_parameters/","title":"Time-Varying Parameters","text":"<p>In real-world epidemic modeling, parameters such as the infection rate (\u03b2) or recovery rate (\u03b3) rarely stay constant. They can change over time due to interventions, behavioral changes, vaccination drives, or environmental factors.</p> <p>Our framework supports time-varying parameters through a flexible design that lets you:</p> <ul> <li>Define parameter schedules in YAML configuration  </li> <li>Generate parameter time series automatically  </li> <li>Integrate them directly into simulations and calibration workflows  </li> </ul>"},{"location":"models/time_varying_parameters/#defining-time-varying-parameters","title":"Defining Time-Varying Parameters","text":"<p>You can define how parameters evolve over time directly in your model configuration file (<code>config.yml</code>) under the <code>time_varying</code> section.</p>"},{"location":"models/time_varying_parameters/#example-sir_model-configuration","title":"Example \u2014 <code>SIR_model</code> Configuration","text":"<p>```yaml SIR_model:   compartments: [S, I, R]   parameters:     beta: 0.3     gamma: 0.1</p> <p>time_varying:     beta:       default: 0.3       schedule:         - {t: 5, value: 0.1}         - {t: 10, value: 0.05}</p> <p>transitions:     S -&gt; I: beta * S * I / N     I -&gt; R: gamma * I</p> <p>initial_conditions:     S: 990     I: 10     R: 0</p> <p>simulation_time: 30</p>"},{"location":"usage/noise_injection/","title":"Noise Injection","text":"<p>To simulate measurement noise, Gaussian noise is added to the clean trajectories:</p> \\[ y_{\\text{noisy}}(t) = y_{\\text{clean}}(t) + \\epsilon(t),\\quad \\epsilon(t)\\sim \\mathcal{N}(0, \\sigma^2) \\] <ul> <li><code>sigma</code> is configured via <code>noise_std</code> in the YAML.</li> <li>After adding noise, values are clipped to valid ranges (e.g., non-negative, \u2264 population).</li> <li>Optionally round to integers if modeling counts.</li> </ul>"},{"location":"usage/noise_injection/#example","title":"Example","text":"<pre><code>import numpy as np\n\ndef add_noise(traj, sigma, clip_min=0, clip_max=None, round_int=False):\n    noisy = traj + np.random.normal(0, sigma, traj.shape)\n    if clip_max is not None:\n        noisy = np.clip(noisy, clip_min, clip_max)\n    else:\n        noisy = np.clip(noisy, clip_min, None)\n    if round_int:\n        noisy = np.rint(noisy).astype(int)\n    return noisy\n</code></pre>"},{"location":"usage/parameter_fitting/","title":"Parameter Fitting","text":"<p>The framework supports deterministic optimizers and MCMC.</p>"},{"location":"usage/parameter_fitting/#loss-function","title":"Loss function","text":"<p>Default: mean squared error across chosen compartments and sampled time points.</p> \\[ L(\\theta) = \\frac{1}{n}\\sum_{i=1}^n \\sum_{c\\in C_{\\text{fit}}} \\big( y^{\\text{sim}}_c(t_i;\\theta) - y^{\\text{obs}}_c(t_i) \\big)^2 \\] <p><code>C_fit</code> defaults to <code>['I']</code> but can be set via <code>fit_compartments</code> in YAML.</p>"},{"location":"usage/parameter_fitting/#deterministic-optimizers","title":"Deterministic optimizers","text":"<p>Uses <code>scipy.optimize.minimize</code> with method: - <code>\"Nelder-Mead\"</code> (derivative-free) - <code>\"BFGS\"</code> (quasi-Newton) - <code>\"L-BFGS-B\"</code> (bounded, limited-memory)</p> <p>Example usage:</p> <pre><code>from scipy.optimize import minimize\n\ndef loss_fn(theta_vec):\n    # map theta_vec to parameters, simulate, compute MSE on sampled times\n    return mse\n\nres = minimize(loss_fn, x0=[0.2,0.1], method='L-BFGS-B', bounds=[(1e-6,5),(1e-6,5)])\n</code></pre>"},{"location":"usage/parameter_fitting/#basin-hopping","title":"Basin-hopping","text":"<p>Use <code>scipy.optimize.basinhopping</code> to escape local minima; internally runs a local optimizer.</p>"},{"location":"usage/parameter_fitting/#mcmc-emcee","title":"MCMC (emcee)","text":"<p>Set uniform priors (or others) and Gaussian likelihood assuming known noise std:</p> <pre><code>import emcee\ndef log_prior(theta):\n    beta, gamma = theta\n    if 0 &lt; beta &lt; 5 and 0 &lt; gamma &lt; 5:\n        return 0.0\n    return -np.inf\n\ndef log_likelihood(theta):\n    # simulate, compute gaussian log-likelihood with known sigma\n    return ll\n\ndef log_posterior(theta):\n    lp = log_prior(theta)\n    if not np.isfinite(lp):\n        return -np.inf\n    return lp + log_likelihood(theta)\n\nndim, nwalkers = 2, 32\np0 = 1e-3 + np.random.rand(nwalkers, ndim) * 0.1\nsampler = emcee.EnsembleSampler(nwalkers, ndim, log_posterior)\nsampler.run_mcmc(p0, 5000, progress=True)\n</code></pre> <p>Tips: - Ensure walkers are initialized inside prior bounds. - Filter out samples where simulation failed (NaN solutions). - Relax overly narrow priors during debugging.</p>"},{"location":"usage/simulation/","title":"Simulation","text":""},{"location":"usage/simulation/#from-transitions-to-odes","title":"From transitions to ODEs","text":"<p>Given compartments <code>[C1, C2, ..., Ck]</code> and transitions <code>A-&gt;B: expr</code>, we compute for each compartment the net rate:</p> <ul> <li>For <code>A</code> subtract <code>expr</code></li> <li>For <code>B</code> add <code>expr</code></li> </ul> <p>The result is a system:</p> \\[ \\frac{d\\mathbf{y}}{dt} = f(t, \\mathbf{y}; \\theta) \\] <p>where \\(\\mathbf{y} = [S, I, R, ...]\\) and \\(\\theta\\) are the parameters.</p>"},{"location":"usage/simulation/#solver","title":"Solver","text":"<p>The default solver is <code>scipy.integrate.odeint</code> (LSODA). Usage example:</p> <pre><code>from scipy.integrate import odeint\nimport numpy as np\n\ndef rhs(y, t, params):\n    S, I, R = y\n    beta, gamma = params['beta'], params['gamma']\n    N = params['N']\n    dSdt = -beta * S * I / N\n    dIdt = beta * S * I / N - gamma * I\n    dRdt = gamma * I\n    return [dSdt, dIdt, dRdt]\n\nt = np.linspace(0, time, time+1)\ny0 = [990, 10, 0]\nsol = odeint(rhs, y0, t, args=( {'beta':0.3,'gamma':0.1,'N':1000}, ))\n</code></pre>"},{"location":"usage/simulation/#time-dependent-parameters","title":"Time-dependent parameters","text":"<p>If your model requires time-varying parameters, provide an <code>extras_fn(t, y)</code> hook that returns a dict of parameter values at <code>t</code>. The <code>rhs</code> should consult those values when computing rates.</p>"},{"location":"usage/workflow/","title":"Workflow","text":"<p>High-level pipeline:</p> <pre><code>Define YAML \u2192 Generate ODEs \u2192 Simulate \u2192 Add Noise \u2192 Subset \u2192 Fit Parameters \u2192 Visualize &amp; Diagnose\n</code></pre>"},{"location":"usage/workflow/#steps","title":"Steps","text":"<ol> <li>Define YAML: create a model block with compartments, parameters, transitions, population, and initial conditions.</li> <li>Generate ODEs: the framework parses <code>transitions</code> into symbolic rates and constructs the right-hand side of the ODE system automatically.</li> <li>Simulate: integrate the ODE system (default: <code>scipy.integrate.odeint</code>) over the time grid <code>t = 0..time</code>.</li> <li>Add Noise: Gaussian noise is added to simulated trajectories and clipped to valid ranges.</li> <li>Subset Sampling: sample a fraction of time points (<code>subset_ratio</code>) to mimic sparse observations.</li> <li>Fit Parameters: minimize a loss function (default MSE over specified compartments) using chosen optimizers. Optionally run MCMC for posterior estimation.</li> <li>Visualize: produce trajectory plots, loss landscape, and posterior corner plots.</li> </ol>"},{"location":"usage/workflow/#cli-script-example","title":"CLI / Script Example","text":"<p>Run a specific model (defined in your YAML configuration) by name:</p> <pre><code>python main.py --model SIR_model\n</code></pre> <p>After running, you\u2019ll find all outputs in the <code>plots/&lt;model_name&gt;/</code> folder.</p>"}]}